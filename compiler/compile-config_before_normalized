#!/usr/bin/env bash
# compile-config_before_normalized -- Extends deepdive.conf in JSON with more default extractors
#
# - a deepdive-load extractor for relations declared in schema but lacking an extractor that outputs it
##
exec -a "$0" jq '

# duplicate the original deepdive config object
.deepdive_ = .deepdive | .deepdive_ as $deepdive

# make sure at least they are empty objects
| .deepdive_.schema                |= . + {}
| .deepdive_.schema.variables      |= . + {}
| .deepdive_.schema.relations      |= . + {}
| .deepdive_.extraction            |= . + {}
| .deepdive_.extraction.extractors |= . + {}
| .deepdive_.inference             |= . + {}
| .deepdive_.inference.factors     |= . + {}
| .deepdive_.pipeline              |= . + {}
| .deepdive_.pipeline.pipelines    |= . + {}

# add an database initialization extractor
| .deepdive_.extraction.extractors +=
    { "init/db": { style: "cmd_extractor"
                 , cmd: "deepdive initdb"
                 }
    }

# add initialization extractors that loads data into base relations declared in schema
| .deepdive_.extraction.extractors += (
    # first a handy map from relation to any process that outputs it
    ( $deepdive.extraction.extractors | with_entries
    ( { key: (.value.output_relation // empty), value: .key }
        )) as $output_by_process |
    [ $deepdive.schema.relations // {} | to_entries[]
    | select($output_by_process[.key] | not)
    | { key: "init/relation/\(.key)"
      , value: { style: "cmd_extractor"
               , cmd: "deepdive initdb \(.key | @sh) && deepdive load \(.key | @sh)"
               , dependencies: [ "init/db" ]
               , output_relation: .key
               } }
    ] | from_entries )

'
