#!/usr/bin/env bash
# deepdive-corenlp-start -- Starts CoreNLP HTTP server for use with DeepDive
# $ deepdive corenlp start PORT
#
# $ export CORENLP_PORT=PORT
# $ deepdive corenlp start
##
set -euo pipefail

: ${CORENLP_HOME:?} ${CORENLP_PORT:?}
: ${CORENLP_JAVAOPTS:=}
: ${CORENLP_START_DELAY:=120} # wait for a minute on average

deepdive-corenlp-installed

# override CORENLP_PORT if argument is given
[[ $# -eq 0 ]] || CORENLP_PORT=$1

pid_file="$CORENLP_HOME"/server-port"$CORENLP_PORT".pid

# emulate a lock to elect a single process to actually launch CoreNLP when there's contention
set -o noclobber
{ echo $$ >"$pid_file".launching; } 2>/dev/null || {
    if pid=$(cat "$pid_file".launching 2>/dev/null) && ! ps -p "$pid" &>/dev/null; then
        # but take over stale locks
        set +o noclobber
        echo $$ >"$pid_file".launching
        sleep 0.$RANDOM
    fi
}
set +o noclobber
is_elected=true; [[ $(cat "$pid_file".launching 2>/dev/null) = $$ ]] || is_elected=false

# don't start a new one when something's already running
if [[ -s "$pid_file" ]]; then
    if deepdive-corenlp-curl --data-raw 'ping' &>/dev/null; then
        warning "CoreNLP server at CORENLP_PORT=$CORENLP_PORT already running (PID $(cat "$pid_file"))"
    elif $is_elected; then
        # pid file seems stale
        rm -f "$pid_file"
    fi
fi

# start CoreNLP server
if $is_elected; then
    if ! [[ -s "$pid_file" ]]; then
        echo >&2 "CoreNLP server at CORENLP_PORT=$CORENLP_PORT starting..."
        touch "$pid_file"
        # cope with thrashing issue when many CoreNLP servers are loading all at the same time
        # unless a particular CoreNLP server port is being explicitly set
        # or CoreNLP server is started outside of DeepDive's UDF
        if ! $CORENLP_PORT_SET && [[ -n ${DEEPDIVE_CURRENT_PROCESS_INDEX:-} ]]; then
            # XXX CoreNLP ObjectInputStream uses all cores while loading models no matter what -t flag we pass
            # which can be devastating when multiple UDFs try to launch many servers at once
            # so we must cope with the impact of simulateneous loading somehow
            if type taskset &>/dev/null; then
                # On Linux, limit number of cores JVM can see with taskset(1)
                java() { taskset $DEEPDIVE_CURRENT_PROCESS_INDEX java "$@"; }
            else
                # On Mac and other platforms, serialize the loading process by
                # waiting until the previous one becomes ready
                # TODO find a way to limit JVM threads on Mac
                case $DEEPDIVE_CURRENT_PROCESS_INDEX in
                    1)
                        : # the first process should just proceed
                        ;;
                    *)
                        # others should wait on the previous one
                        portToWaitOn=$(($CORENLP_PORT - 1))
                        num_retries=1200
                        while ! CORENLP_PORT=$portToWaitOn deepdive-corenlp-curl --data-raw 'ping' &>/dev/null
                        do sleep 0.$((1 + $RANDOM % 9))
                            let --num_retries || break
                        done
                esac
            fi
        fi
        # now, actually launch the JVM running CoreNLP server
        java ${CORENLP_JAVAOPTS} -cp "$CORENLP_HOME/*" \
            edu.stanford.nlp.pipeline.StanfordCoreNLPServer \
            --port $CORENLP_PORT >/dev/null &
        echo $! >"$pid_file"
    fi
    rm -f "$pid_file".launching
fi

# wait for CoreNLP server to boot up
CORENLP_SERVER_ENDPOINT=$(deepdive-corenlp-server-url)
export CORENLP_SERVER_ENDPOINT
while ! deepdive-corenlp-curl --data-raw 'ping' &>/dev/null
do sleep 0.$((1 + $RANDOM % 9))
    let --CORENLP_START_DELAY ||
        error "CoreNLP server at CORENLP_PORT=$CORENLP_PORT still not ready"
done
echo >&2 "CoreNLP server at CORENLP_PORT=$CORENLP_PORT ready"
