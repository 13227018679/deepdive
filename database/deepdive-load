#!/usr/bin/env bash
# deepdive-load -- Loads a given relation's data
# > deepdive load RELATION[(COLUMN[,COLUMN]...)] [SOURCE...]
# Initializes given RELATION in the database and loads data from SOURCE for
# optionally specified COLUMNs.  When SOURCE is unspecified, the data is loaded
# from files found on path input/RELATION.* under the DeepDive application.
#
# When RELATION is a random variable and no COLUMN is specified, the SOURCE are
# expected to contain the `label` column at the end, in addition to all
# user-defined ones.
#
# This command must be run under an environment whose DEEPDIVE_DB_URL variable
# is set to a proper URL, or under a DeepDive application where the URL is set
# in the db.url file.
#
# For example:
#
# > deepdive load sentences
# creates table 'sentences' and loads data from input/sentences.tsv if there
# is one.
#
# > deepdive load sentences path/to/sentences.tsv
# creates table 'sentences' and loads data from path/to/sentences.tsv.
#
# > deepdive load sentences sentences.csv.bz2
# creates table 'sentences' and loads from a compressed CSV file.
##
set -eu

# skip detection of the data format and assume
: ${DEEPDIVE_LOAD_FORMAT:=}

[[ $# -gt 0 ]] || error "Missing RELATION to load"
Relation=$1; shift
Columns=

# parse optional columns following relation name
case $Relation in
    *"("*")")
        # keep column names separate
        Columns="${Relation#*"("}"
        Columns=${Columns%")"}
        Relation=${Relation%%"("*}
esac

# when no SOURCE is specified, look under input/
if [[ $# -eq 0 ]]; then
    DEEPDIVE_APP=$(find-deepdive-app)
    export DEEPDIVE_APP
    . load-db-driver.sh

    cd "$DEEPDIVE_APP"
    initsh=input/init_"$Relation".sh
    # check if init_RELATION.sh script is available
    if [[ -x "$initsh" ]]; then
        echo "Loading $Relation via $initsh"
        exec "$initsh" "$@"
    fi
    # search under input/RELATION.*
    for Path in input/"$Relation".{tsv,csv,json-seq,sql}{,.bz2,.gz,.sh}; do
        [[ -e "$Path" ]] || continue
        break
    done
    [[ -e "$Path" ]] ||
        error "input/$Relation.*: No data source found for $Relation"
    # use the found path
    set -- "$Path"
else
    # rely on the app if found (optional)
    DEEPDIVE_APP=$(find-deepdive-app 2>/dev/null) || true
    export DEEPDIVE_APP
    . load-db-driver.sh
fi

# find the columns to load (when no $Columns were explicitly specified and
# $Relation is a random variable, load the user-defined columns with the
# internal label column but nothing else)
if [[ -z "$Columns" && -e "$DEEPDIVE_APP" ]] && app-has-been-compiled; then
    Columns=$(
        cd "$DEEPDIVE_APP"
        Relation=$Relation \
        jq -r '
            .deepdive_.schema.relations[env.Relation] |
            if .variable_type then
                .columns | to_entries |
                sort_by(.value.index) |
                map(.key)+["label"] | join(",")
            else
                empty
            end
        ' run/compiled/config.json
    )
fi

# load each path given as arguments
# TODO group paths by format, and batch call to load to support parallel load
for path; do

# determine the format
if [[ -n "$DEEPDIVE_LOAD_FORMAT" ]]; then
    # assume a format when explicitly specified
    format=$DEEPDIVE_LOAD_FORMAT
else
    case $path in
        *.tsv|*.tsv.*)           format=tsv      ;;
        *.csv|*.csv.*)           format=csv      ;;
        *.json-seq|*.json-seq.*) format=json-seq ;;
        *.sql|*.sql.*)           format=sql      ;;
        *) error "$path: Unrecognized format, specify DEEPDIVE_LOAD_FORMAT="
    esac
fi
# and how to load it
case $format in
    sql) load() { db-execute "$(cat "$@")"; } ;;
    *)   load() { db-load "$Relation" "$Columns" "$format" "$@"; }
esac
# and how to decompress if needed
case $path in
    *.bz2) decompress=bzcat ;;
    *.gz)  decompress=zcat  ;;
    *.sh)  decompress=bash  ;;
    *)     decompress=
esac

# load the data
echo "Loading $Relation from $path ($format format)"
if [[ -n "$decompress" ]]; then
    # after decompressing if needed
    load <($decompress "$path")
else
    load "$path"
fi

done
