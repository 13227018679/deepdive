#!/usr/bin/env bash
# db-assign_sequential_id -- Assigns a unique integer to every row for a table using PostgreSQL sequence generator
# > eval "$(db-parse "$url")"
# > db-assign_sequential_id TABLE COLUMN BEGIN_ID [INCREMENT]
##
set -euo pipefail

[[ $# -gt 0 ]] || usage "$0" "Missing TABLE"
[[ $# -gt 1 ]] || usage "$0" "Missing COLUMN"
[[ $# -gt 2 ]] || usage "$0" "Missing BEGIN_ID"
Table=$1 Column=$2 BeginId=$3 Increment=${4:-1}

# Use Greenplum PL/pgSQL and PL/Python UDFs to assign IDs fast
# See: http://www.postgresql.org/docs/8.2/static/sql-createlanguage.html
# See: http://www.postgresql.org/docs/8.2/static/plpgsql-overview.html
# See: http://www.postgresql.org/docs/8.2/static/plpython-funcs.html
db-execute "CREATE LANGUAGE plpgsql;" || true
db-execute "CREATE LANGUAGE plpythonu;" || true
db-execute "
    CREATE OR REPLACE FUNCTION clear_count_1(sid INT) RETURNS INT AS
    \$\$
    if '__count_1' in SD:
      SD['__count_1'] = -1
      return 1
    return 0 # XXX why return a confusing 0 when it still counts toward COUNT()?
    \$\$ LANGUAGE plpythonu;

    CREATE OR REPLACE FUNCTION updateid(startid BIGINT, increment BIGINT, sid INT, sids INT[], base_ids BIGINT[], base_ids_noagg BIGINT[]) RETURNS BIGINT AS
    \$\$
    if '__count_1' in SD:
      a = SD['__count_2']
      b = SD['__count_1']
      SD['__count_2'] = SD['__count_2'] - 1
      if SD['__count_2'] < 0:
        SD.pop('__count_1')

    else:
      for i in range(0, len(sids)):
        if sids[i] == sid:
          SD['__count_1'] = base_ids[i] - 1
          SD['__count_2'] = base_ids_noagg[i] - 1
      a = SD['__count_2']
      b = SD['__count_1']
      SD['__count_2'] = SD['__count_2'] - 1
      if SD['__count_2'] < 0:
        SD.pop('__count_1')

    return startid + increment*(b-a)

    \$\$ LANGUAGE plpythonu;

    CREATE OR REPLACE FUNCTION fast_seqassign(tname character varying, cname character varying, startid bigint, increment bigint) RETURNS TEXT AS
    \$\$
    BEGIN
      EXECUTE 'DROP TABLE IF EXISTS tmp_gpsid_count       CASCADE;';
      EXECUTE 'DROP TABLE IF EXISTS tmp_gpsid_count_noagg CASCADE;';
      EXECUTE 'CREATE TABLE tmp_gpsid_count       AS SELECT gp_segment_id AS sid, COUNT(clear_count_1(gp_segment_id)) AS base_id FROM ' || QUOTE_IDENT(tname) || ' GROUP BY gp_segment_id ORDER BY sid DISTRIBUTED BY (sid);';
      EXECUTE 'CREATE TABLE tmp_gpsid_count_noagg AS SELECT *                                                                    FROM tmp_gpsid_count                                                  DISTRIBUTED BY (sid);';
      EXECUTE 'UPDATE tmp_gpsid_count AS t SET base_id = (SELECT SUM(base_id) FROM tmp_gpsid_count AS t2 WHERE t2.sid <= t.sid);';
      RAISE NOTICE 'EXECUTING _fast_seqassign()...';
      EXECUTE 'SELECT * FROM _fast_seqassign(''' || QUOTE_IDENT(tname) || ''', ''' || QUOTE_IDENT(cname) || ''', ' || startid || ', ' || increment || ');';
      RETURN '';
    END;
    \$\$ LANGUAGE 'plpgsql';

    CREATE OR REPLACE FUNCTION _fast_seqassign(tname CHARACTER VARYING, cname CHARACTER VARYING, startid BIGINT, increment BIGINT)
    RETURNS TEXT AS
    \$\$
    DECLARE
      sids              INT[]    := ARRAY(SELECT sid     FROM tmp_gpsid_count       ORDER BY sid);
      base_ids          BIGINT[] := ARRAY(SELECT base_id FROM tmp_gpsid_count       ORDER BY sid);
      base_ids_noagg    BIGINT[] := ARRAY(SELECT base_id FROM tmp_gpsid_count_noagg ORDER BY sid);
      tsids             TEXT;
      tbase_ids         TEXT;
      tbase_ids_noagg   TEXT;
    BEGIN
      SELECT INTO tsids           ARRAY_TO_STRING(sids, ',');
      SELECT INTO tbase_ids       ARRAY_TO_STRING(base_ids, ',');
      SELECT INTO tbase_ids_noagg ARRAY_TO_STRING(base_ids_noagg, ',');
      IF ('UPDATE ' || tname || ' SET ' || cname || ' = updateid(' || startid || ', ' || increment || ', gp_segment_id, ARRAY[' || tsids || '], ARRAY[' || tbase_ids || '], ARRAY[' || tbase_ids_noagg || ']);')::TEXT IS NOT NULL THEN
        EXECUTE 'UPDATE ' || tname || ' SET ' || cname || ' = updateid(' || startid || ', ' || increment || ', gp_segment_id, ARRAY[' || tsids || '], ARRAY[' || tbase_ids || '], ARRAY[' || tbase_ids_noagg || ']);';
      END IF;
      RETURN '';
    END;
    \$\$
    LANGUAGE 'plpgsql';

    SELECT fast_seqassign('$Table', '$Column', $BeginId, $Increment);
" && exit

# Fall back to using PostgreSQL sequence generator named after the table and column
# See: http://www.postgresql.org/docs/current/static/sql-createsequence.html
seq="dd_seq_${Table}_${Column}"
deepdive sql "
    DROP SEQUENCE IF EXISTS $seq CASCADE;
    CREATE TEMPORARY SEQUENCE $seq INCREMENT BY $Increment MINVALUE $(($BeginId - 1)) START $BeginId;

    UPDATE $Table SET $Column = nextval('$seq');
"
