#!/usr/bin/env bash
# db-assign_sequential_id -- Assigns a unique integer to every row for a table using PostgreSQL sequence generator
# > eval "$(db-parse "$url")"
# > db-assign_sequential_id TABLE ID_COLUMN [PART_ID_COLUMN]
##
set -euo pipefail

[[ $# -gt 0 ]] || usage "$0" "Missing TABLE_CSV"
[[ $# -gt 1 ]] || usage "$0" "Missing ID_COLUMN"

TABLE_CSV=$1 IdColumn=$2 PartColumn=${3:-0}


SQL="
    CREATE OR REPLACE FUNCTION seqassign(partid INT, reset BOOL, pids INT[], offsets BIGINT[])
    RETURNS BIGINT AS \$\$
      if reset:
        for i, pid in enumerate(pids):
          SD[pid] = offsets[i]
        return 0

      x = SD[partid]
      SD[partid] += 1
      return x + (partid << 48)
    \$\$ LANGUAGE plpythonu;

    SELECT seqassign(1 << 16, true);

    CREATE TEMP TABLE idstats(pid INT, tname TEXT, gpsid INT, total BIGINT);
"


for table in $(echo $TABLE_CSV | sed "s/,/ /g")
do
    SQL="$SQL
    INSERT INTO idstats
      SELECT $PartColumn, '$table', gp_segment_id, COUNT(1)
      FROM $table
      GROUP BY $PartColumn, gp_segment_id;"
done

# http://stackoverflow.com/questions/22841206/calculating-cumulative-sum-in-postgresql
SQL="$SQL
CREATE TEMP TABLE idstats_rollup AS
  SELECT pid, gpsid, total, SUM(total) OVER (PARTITION BY pid ORDER BY gpsid) AS cum_total
  FROM (
    SELECT pid, gpsid, SUM(total) as total
    FROM idstats
    GROUP BY pid, gpsid
    ORDER BY pid, gpsid
  ) t;

CREATE TEMP TABLE idstats_bases AS
  SELECT
    gpsid,
    ARRAY_AGG(pid ORDER BY pid) as pids,
    ARRAY_AGG(cum_total - total ORDER BY pid) as offsets
  FROM idstats_rollup
  GROUP BY gpsid;

SELECT seqassign(NULL, true, pids, offsets)
  FROM idstats_bases
  WHERE gpsid = gp_segment_id;

"

for table in $(echo $TABLE_CSV | sed "s/,/ /g")
do
    SQL="$SQL
    UPDATE $table SET $IdColumn = seqassign($PartColumn, false, NULL, NULL);"
done

db-execute "$SQL"
